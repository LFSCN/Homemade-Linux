## 第 1 章 介绍

### 1.1	Linux 的始末 

#### 1.1.1 Unix 的发展过程

1969 年，AT&T 旗下著名的贝尔实验室（Bell Labs）由于迫于开发速度过慢退出了 Multics 的开发计划。Multics 是一个 1964 年开始的项目，早期由通用电气（General Electric）和麻省理工学院（MIT）合作计划，打算打造出一套多用户、多任务、多层次（multi-user、multi-processor、multi-level）的 Multics 操作系统。贝尔实验室于 1965 年加入该项目，经过了 4 年的努力，这个糅合了太多的特性的 Multics 虽然发布了一些产品，但是性能都很低，AT&T 最终选择撤出了投入 Multics 项目的资源，退出这项合作计划。

虽然 Multics 计划已然行将就木，但被用于开发 Multics 项目的大型主机 GE-645 仍然保留在贝尔实验室。这可能就是命运，此时一个刚刚被招募加入该计划的年轻人在 GE-645 上，写出了一个仿真器，可以让文件系统与内存分页机制运作起来。他同时也写了一个程序语言 Bon，并用其编写了一个太空旅行游戏。在 GE-645 被搬走后，他在实验室中寻找没人使用的机器，并在涨他两岁的同事丹尼斯·里奇（丹尼斯·麦卡利斯泰尔·里奇 Dennis MacAlistair Ritchie）的帮助下，成功的在 PDP-7 上用汇编语言重写了这个游戏。他进入 Multics 计划不久，计划就中止了，但为数不多的项目经验促使着他在 PDP-7 上继续研究如何开发系统。熟悉这段历史的人应该知道，这位年轻人就是大名鼎鼎的肯·汤普逊（肯尼斯·蓝·汤普逊 Kenneth Lane Thompson）。

在肯·汤普逊和丹尼斯·里奇的主导下，加上近乎 Multics 计划的原班人马的不懈努力，Unix 先后经历三个版本，终于在 1973 年用 C 语言重写的第三版中稳定下来。用 C 语言编写的 Unix 代码简洁紧凑、易移植、易读、易修改，为此后 Unix 的发展奠定了坚实基础。

此后的近 10 年里，Unix 在学术机构和大型企业中得到了广泛的应用，当时的 Unix 拥有者 AT&T 公司以低廉甚至免费的许可将 Unix 源码授权给学术机构做研究或教学之用，许多机构在此源码基础上加以扩展和改进，形成了所谓的变种，这些变种反过来也促进了 Unix 的发展，其中最著名的变种之一是由加州大学柏克莱分校开发的 BSD（伯克利软件包 Berkeley Software Distribution）。

但好景不长，这段蜜月期很快就过去了。随着 AT&T 逐渐意识到了 Unix 的商业价值，便开始不再将源码授权给学术机构，随后的一切愈演愈烈。直到后来 Unix 和 BSD 变种这对郎才女貌，最终落到对簿公堂。这场官司一直打到 AT&T 把 Unix 系统实验室卖给 Novell。

后面发生了什么对我们已经不重要了，至少对本书而言并不重要。我们只消知道 Unix 的由来和商业化途中的一地鸡毛即可。当然还需要了解一下彼时与 BSD 变种争锋相对的 UNIX System V。因为目前的 LFS 分为 2 个版本：System V 和 systemd，虽然 LFS 的 System V 和 UNIX System V 并不是一回事，但是既然后面会有所提及，这里就先解释一下 UNIX System V。

UNIX System V 最初由 AT&T 开发，在 1983 年第一次发布，因此也被称为 AT&T System V。一共发行了 4 个主要版本：1、2、3 和 4。第 4 个版本被称为 System V Release 4，或者简称为 SVR4，是其中最成功的版本。

介绍一下 System V Release 4 得特性。

#### 1.1.2 RMS 和 GNU 工程

RMS 是一个人名理查德·马修·斯托曼（Richard Matthew Stallman），美国程序员，同时也是自由软件运动的推动者。而 GNU 工程也就是开发 GNU 系统的工程。不过，GNU 工程并不限于核心操作系统。我们的目标是提供一个完整的软件系列，满足多数用户的使用要求，包括应用软件。若问及为什么要但开一个小节介绍 RMS 和 GNU 工程。那就让我们翻到本书的目录，好好数数第 3 章、第 4 章要装多少 g 开头的软件包，这其中不说全数，大多数的 g 都是 GNU 的意思。

让我们把时间调回到 1971 年，彼时的 RMS 刚刚在 MIT 开始他的职业生涯。那个时代时甜蜜的时代，当时的计算机公司都经常发布自由软件，程序员们可以自由地相互合作。还记得同样是那个时代 Unix 诞生，并在这样的环境中茁壮成长。但随着时间来到 20 世纪 80 年代，放眼望去，几乎所有的软件都是专属软件了。专属软件的出现意味着软件有了拥有者，一个禁止和阻止用户合作的拥有者。这种商业形式摧毁了之前十余年的合作模式，这导致给予他人帮助变得越来越难，社区也开始日益萎缩。

当时摆在 RMS 面前的选择有很多，值得庆幸的是他选择了坚守自己的本心。为了重建社区，首当其冲的就是他和他们需要一个操作系统，一个自由的操作系统。为了致敬 Unix，他将着手的系统命名为 GNU，意为 GNU's Not Unix。

GNU 操作系统进度是很快的，从 1984 年 RMS 离开 MIT 算起，直到 1990 年 GNU 系统除了内核，其他的部分基本上都完成了。当时决定采用的内核是 Hurd，但最后的结果大家也都知道了。1991年，Linus Torvalds 开发了一个和 Unix 兼容的内核，并称之为 Linux。一开始 Linux 是专有软件，但是在 1992 年，Linus 将 Linux 变成了自由软件。把 Linux 和还不完全的 GNU 系统结合在一起就形成了一个完全的自由软件操作系统。

关于这个完全的自由软件操作系统的称呼其实还有 GNU/Linux 这种叫法。为了这个系统 GNU 工程努力多年，最后因为使用了 Linux 内核而把自己的名字也丢了，这点确实让人难以接受，所以他们提出用 GNU/Linux 这一提议也是情理之中。有很多人表示支持，作者本人也觉得挺合理。不过事与愿违，不仅有不少的一部分认为系统的关键是内核，并不认同这一提议。而且，大多数人们更喜欢使用 Linux 操作系统去称呼这个自由的系统，因为这样更顺口。本书采用的也是 Linux 系统这种说法，若单指内核会采用 Linux 内核用以区分。

这里关于 RMS 和 FSF 相关的更多故事就不做介绍了，可以到 GNU 的官网 https://www.gnu.org 自行查阅。对于 RMS 和 FSF 做的那些事我只能说敬畏、佩服，如果你现在还没有这种感觉，那等我们完成这本 LFS 的所有构建工作后，你应该会有更深的体验。

#### 1.1.3 Linus 和 Linux 内核

上节已经提过 1991 年 Linus 开发了 Linux 内核，并通过自己和多方的努力打造了以 Linux 内核为核心的自由系统。这个系统之所以以 Linux 之名广为流传，其实最根本的原因就是内核对于系统的重要性。

举一个例子，如果 Ubuntu 系统（一个 Linux 的发行版）没有预装 Emacs（GNU 的一款文本编辑器），那我们可以自行安装 Emacs，这个时候我们会主观的认为 Emacs 不是 Ubuntu 的一部分。那么同为文本编辑器的 vi 呢？大多数的 Linux 会预装 vi 编辑器，但 vi 对于 Linux 系统也不是必须的。即使是强如 GCC，也可以被替代，如果你真的闲着没事可以试试看用 Clang 来编译一下 Linux 内核。这件事在理论上可行，但我不能保证你在实施的过程中能一帆风顺，当然如果你真的打算这么试试可以检索一下 LLVMLinux，会对你有所帮助。

当然 Linux 内核也并不是无可替代的，事实上 GNU 的 Hurd 已经可以使用了。虽说用 Hurd 替换了 Linux，那么这个系统显然就不能称为 Linux 系统了，但这种解释简直就是狡辩，所以这里稍微解释一下 Linux 内核起到的作用。

Linux 内核支持抢占式多任务处理（preemptive multitasking）、虚拟内存（virtual memory）、共享库、请求分页（demand loading）、共享写时复制可执行体（shared copy-on-write executables）、内存管理以及线程等功能。从实现的功能就可以看得出，一个内核对于系统的重要性，就相当于是在在凹凸不平的路面上铺上一层平坦的水泥，这样程序在你的计算机里才能有序的运行。

所以 Linux 内核之于 Linux 系统，用一句流行的说法就叫作注入灵魂。内核是系统核心，她决定了系统的性格，也决定了系统的内在基因。Linux 内核对于 Linux 系统来说固然是重要的，但是要做到让 Linux 系统持续保持流行，仅仅是这一点显然是不够的。

Linux 是一个宏内核（Monolithic kernel），与之相对的是微内核（Microkernel）。使用此架构的内核是一个单一的二进制可执行文件，在内核态以监管者模式（Supervisor Mode）运行。其优点是内核之中的通信成本很小，内核可以直接调用内核态内的函数，因此性能很好。1980 年代前的所有操作系统都采用这种方式实现，也包括 Unix。但是也有一个很大的缺点，就是移植性不好。

这一点 Linus 自己也承认，他的初衷也并不是使 Linux 成为一个可移植的操作系统。不过有趣的是，事与愿违，Linux 是世界上被移植的最广泛的操作系统内核。服务器、手机、游戏机，即使是 Windows 制霸的桌面端相信本书的读者也有很一部分用的是 Linux 的某个发行版。

Linux 内核之所以能在如此漫长的岁月中稳步发展有很大一部分原因是它的开发模式。这种人人都有机会贡献出自己能量的开发模式，吸引到了众多的开发者加入到完善 Linux 内核的过程中。在书写本小节的同时我又重看了一边 Linus 在 2017 年北京的 LC3 的采访。当时我也在会场，我记他说的一些话，其中有一些特别适合放在这，这里摘抄两段：

> “我觉得有趣的是我认为已经稳定的代码仍然在不断的得到改进，有些东西我们已经很多年没有碰了，然后有人来改进了它们，或者在我以为根本就不会有人用的东西上提交了 Bug 报告。我们有了新的硬件，开发了新的功能，但是 25 年后，我们仍然有老的、非常基础的东西，并且人们依然在关心和改善着它们。”

> “当我坐下来开始写 Git ，一个首要的原则就是你应该能 fork 并且在此基础上做你自己的事情。如果你有友好的 fork（能证明我错了，并且能够改进内核），在这种情况下，人们可以回来说我们实际上改进了内核，这没有什么不好的感觉。我会采纳你的改进并且将其合并进来。这就是为什么你应该鼓励 fork 。你也想让良好的回馈变得很简单。”

采访的视频链接：https://linux.cn/article-8638-1.html

从 Linus 的话中，我们可以看出他对于开发维护 Linux 内核的态度。真的十分感谢 Linus、内核的开发维护人员以及为 Linux 内核提交过贡献的人们。没有他们，Linux 不可能发展的如此迅速，也不可能在稳定之后仍能持续完善。

#### 1.1.4 Linux 的发行版

首先，说起 Linux 的发行版，我想先分享一个张图 https://upload.wikimedia.org/wikipedia/commons/1/1b/Linux_Distribution_Timeline.svg。真的是太夸张了，对比他的老前辈 Unix 简直有过之而无不及。

Linux 发行版指的就是通常所说的 “Linux 操作系统”，它一般是由一些组织、团体、公司或者个人制作并发行的。Linux 内核主要作为 Linux 发行版的一部分而使用。通常来讲，一个 Linux 发行版包括 Linux 内核，以及将整个软件安装到计算机上的一套安装工具，还有各种 GNU 软件，和其他的一些自由软件，在一些 Linux 发行版中可能会包含一些专有软件。

流行的发行版有基于 RPM（Red Hat系）的 RHEL（Red Hat Enterprise Linux）、Fedora、CentOS 和 openSUSE 等；基于 Dpkg（Debian系）的 Debian、Ubuntu 和 Linux Mint 等；以及不同于以上两类的 ArchLinux、Gentoo 和 Slackware 等，主要根据软件包管理方式给出的分类。

### 1.2	Linux From Scratch 项目

Linux From Scratch （简写 LFS）是由 Gerard Beekman 等人编写的一本书，目前主要由 Bruce Dubbs 维护。

其实承接上文，我是想写 LFS 是其中比较特殊的发行版。相信这样认为的人不在少数，至少我之前有在 LFS 相关的文章中看到过，而且 distrowatch 其实也能找到 [LFS][https://distrowatch.com/table.php?distribution=lfs] ，这就说明这句话本身不存在什么问题。但转念一想，这样描述又确实有欠妥当，特别是当我有重新翻了翻 [LFS 的官网][http://www.linuxfromscratch.org] 之后，官网对于 LFS 的描述是：

> Linux From Scratch (LFS) is a project that provides you with step-by-step instructions for building your own custom Linux system, entirely from source code.
> Currently, the Linux From Scratch organization consists of the following subprojects:

换言之，他们自己其实认为 LFS、BLFS 等都是项目我还对比查看了 RHEL 和 Ubuntu 的官网，他们两者都在描述中清清楚楚的写明了他们是操作系统（operating system）。

#### 1.2.1 LFS 的目的 

LFS 主要提供分步指导，帮助读者通过编译源代码的方式，自行构建出属于自己的 Linux 系统。这个项目最大意义其实是教学，帮助读者了解 Linux 的内部的工作原理，了解程序是如何协同工作和相互依赖的，同时培养读者亲手定制满足自己需求的 Linux 系统的能力。

翻译、维护了 LFS 好些年，我一直觉得 LFS 其实可以写的更生动一点，其中实际讲述原理的地方比较少，还集中在一起，而且还没有指令，我看到好多初学者就直接跳过了。也不太理解虽然排版的非常整齐，但罗列的东西很多还不带重点，很容易让人觉得枯燥。

不过在整理这本书的时候我有点理解了，这本书要讲、可以讲的东西太多了，不可能全都写下来，索性把构建过程写的简洁明了，软件包信息罗列完整，依赖等不太常用的信息放到目录，原理的教学在开始前事先讲解完。这样书本会显得简洁，并且易于查找，维护起来也会方便很多。

不过我们还是想试着去让这本书变得有意思一点。我们会删减掉一些意义不大的信息，加入一些我们觉得有必要或有意思的内容来充实无聊的构建过程。LFS 项目的目的就是我们的目的，不过我们也希望读者在学习途中不要那么枯燥、不那么累。

#### 1.2.2 LFS 的目标架构

LFS 当前主要支持 AMD/Intel 的 x86（32 位）和 x86_64（64 位）构架的 CPU。另外，也涉及一些更改以允许 LFS 顺利地在 Power PC 和 ARM CPU 上运行。

假如 LFS 默认的方式构建，那么你将得到一个「纯」 64 位系统——这意味着你仅能够执行 64 位的程序。如果同时也想执行 32 位的程序，那很多程序就需要编译两次。

早期的 LFS 推荐使用 32 位系统构建，但近两个版本出现了一句注意事项，通过这句注意事项，我们可以看出 LFS 对于目标架构态度的转变。“LFS 作者建议，如果有机会，尽量在 64 位系统上进行构建。”

这个问题其实也并不用纠结，能用 64 位就 64 位，没有几个构建者最终会把 LFS 作为主力使用的系统。即使真的要做主力系统，自然也有办法解决。

#### 1.2.3 LFS 遵循的标准

LFS 的结构尽可能的遵循 Linux 的标准。主要的标准有：POSIX.1-2008.、FHS 3.0 和 LSB 5.0

由于 LFS 的安装方式是纯手动编译的方式，也就是说用户对于需求软件包拥有完全的控制权，所以你构建出来的系统大可不必遵循任何标准。

不过大多数的发行版还是能做到基本遵守这三个标准的，所以还是有必要了解以下的。

##### 1.2.3.1 可移植操作系统接口（POSIX）

POSIX（Portable Operating System Interface，可移植操作系统接口）这个名称是由 RMS 应 IEEE 的要求而提议的一个易于记忆的名称。它基本上是首字母缩写，而 X 则表明其对 Unix API 的传承。Linux 基本上逐步实现了 POSIX 兼容，但并没有参加正式的 POSIX 认证。同时，Linux 也影响到了 POSIX 后续的发展。

POSIX.1-2008 同时是 IEEE Std 1003.1™-2008 和开放组技术标准基础规范。定义了标准操作系统接口和环境，包括命令解释器（或 “shell”），以及支持源代码级别的应用程序可移植性的通用实用程序。

POSIX.1-2008 旨在供应用程序开发人员和系统实现者使用，并包含 4 个主要组件，分别包含在关联的 4 个卷中：

基本定义卷: 所有卷通用的一般术语、概念和接口，包括实用程序约定和 C 语言头定义

系统接口卷: 系统服务功能和子例程的定义，C 编程语言的特定于语言的系统服务，功能问题（包括可移植性，错误处理和错误恢复）。

Shell 和 Utilities 卷：命令解释服务的标准源代码级接口（“shell”）和应用程序的通用实用程序的定义。

基本原理（资料性）卷：扩展原理不适合文档结构的其余部分，其中包含有关 POSIX.1-2008 内容的历史信息以及标准开发人员包含或丢弃功能的原因。

POSIX.1-2008 描述了对应用程序开发人员而言非常重要的外部特征和设施，而不是用于实现这些功能的内部构造技术。特别强调各种商业应用所需的功能和设施。

根据流程构建出来的自定义 Linux 系统基本兼容 POSIX，不需要读者额外操作。POSIX 在 Linux 相关的文章中出现频率很高，这里科普一下。

##### 1.2.3.2 文件系统层次结构标准（FHS）

FHS（Filesystem Hierarchy Standard，文件系统层次结构标准）定义了 Linux 操作系统中的主要目录及目录内容。FHS 由 Linux 基金会维护。 当前版本为 3.0 版，于 2015 年发布。多数 Linux 发行版遵从 FHS 标准并且声明其自身政策以维护 FHS 的要求。

这个标准就是告诉你 “/” 是根目录，根目录的功能是什么...下面要放什么目录、文件，这些目录、文件的功能又是什么的标准。

在构建途中会专门创建这些目录、文件以满足该标准。

##### 1.2.3.3 Linux 标准规范（LSB）

LSB（Linux Standard Base，Linux 标准库）是由 Linux 基金会组织结构下的几个Linux发行版组成的联合项目，用于标准化软件系统结构，包括 Linux 内核中使用的文件系统层次结构标准。LSB 基于 POSIX 规范，单 Unix 规范（SUS）和其他几个开放标准，但在某些领域进行了扩展。

LSB的目标是开发和推广一系列开放标准，这些标准将提高 Linux 发行版之间的兼容性，并使软件应用程序能够在任何兼容系统上运行。LSB合规性可通过认证程序对产品进行认证。

LSB 有四个独立的标准：核心（Core）、桌面（Desktop）、运行时语言（Runtime Languages）和成像（Imaging）。除了通用要求，还有架构特定要求。此外还有两个领域在试行：分别是 Gtk3 和图形（Graphics）。仅构建 LFS 并不能创建一个完全通过 LSB 认证测试的完整系统，需要很多 LFS 范围之外的额外软件包。在 BLFS 中有这些额外软件包的安装说明。


由 LFS 提供，用于满足 LSB 要求的软件包

- LSB 核心：Bash, Bc, Binutils, Coreutils, Diffutils, File, Findutils, Gawk, Grep, Gzip, M4, Man-DB, Ncurses, Procps, Psmisc, Sed, Shadow, Tar, Util-linux, Zlib
- LSB 桌面：无
- LSB 运行时语言：Perl
- LSB 成像：无
- LSB Gtk3 和 LSB 图形（试用）：无

由 BLFS 提供，用于满足 LSB 要求的软件包

- LSB 核心：At, Batch (At 的一部分), Cpio, Ed, Fcrontab, Initd-tools, Lsb_release, NSPR, NSS, PAM, Pax, Sendmail (或 Postfix 或 Exim), time
- LSB 桌面：Alsa, ATK, Cairo, Desktop-file-utils, Freetype, Fontconfig, Gdk-pixbuf, Glib2, GTK+2, Icon-naming-utils, Libjpeg-turbo, Libpng, Libtiff, Libxml2, MesaLib, Pango, Xdg-utils, Xorg
- LSB 运行时语言：Python, Libxml2, Libxslt
- LSB 成像：CUPS, Cups-filters, Ghostscript, SANE
- LSB Gtk3 和 LSB 图形（试用）：GTK+3

LFS 和 BLFS 没有提供，用于满足 LSB 要求的软件包

- LSB 核心：无
- LSB 桌面：Qt4 （以及 Qt5 除外）
- LSB 运行时语言：无
- LSB 成像：无
- LSB Gtk3 和 LSB 图形（试行）：无

#### 1.2.4 SysVinit 和 systemd 的区别

systemd 是 Linux 计算机操作系统之下的一套中央化系统及设置管理程序（init），包括有守护进程、程序库以及应用软件，由 Lennart Poettering 带头开发。其开发目标是提供更优秀的框架以表示系统服务间的依赖关系，并依此实现系统初始化时服务的并行启动，同时达到降低 Shell 的系统开销的效果，最终代替现在常用的 System V 与 BSD 风格 init 程序。

systemd 这一名字源于 Unix 中的一个惯例：在 Unix 中常以 “d” 作为系统守护进程（daemon，亦称后台进程）的后缀标识。除此以外，systemd 亦是借代英文术语 D 体系，而这一术语即是用于描述一个人具有快速地适应环境并解决困难的能力。

当前绝大多数的 Linux 发行版都已采用 systemd 代替原来的 System V。LFS 也不例外，提供了两个版本的构建流程 sysv 对应 System V，systemd 对应 systemd。经过几个版本的演变，这两个版本已经很像了，特别是构建过程，只有临近结束的几个软件包的构建顺序有些差异，其他软件包的构建几乎不受影响。不过在配置的时候差距还是很大的，所以 System V 和 systemd 之间的比较，会留到配置阶段结合实践说明。
